import { Buffer } from 'buffer';
import { lagrange } from '../lagrange';
import { horner } from '../horner';

describe('lagrange', () => {
  it('single point: recovers constant from one evaluation', () => {
    // A constant polynomial p(x) = 42. One point at x=1, y=42.
    // lagrange(0, [[1], [42]]) should return 42.
    const result = lagrange(0, [[1], [42]]);
    expect(result).toBe(42);
  });

  it('constant polynomial: same y for all points returns that y at x=0', () => {
    // If all y values are the same, the interpolated value at any x should be that constant.
    const y = 137;
    const xs = [1, 2, 3];
    const ys = [y, y, y];
    const result = lagrange(0, [xs, ys]);
    expect(result).toBe(y);
  });

  it('recovers secret byte from points generated by horner', () => {
    // Build a polynomial [a0, a1, a2] and evaluate at x=1,2,3 via horner
    // Then recover a0 = p(0) via lagrange interpolation
    const a0 = 99;
    const coefficients = [a0, 45, 210]; // degree-2 polynomial in GF(256)
    const xs = [1, 2, 3];
    const ys = xs.map((x) => horner(x, coefficients));

    const recovered = lagrange(0, [xs, ys]);
    expect(recovered).toBe(a0);
  });

  it('works with threshold subset of points (3-of-5)', () => {
    const a0 = 77;
    const coefficients = [a0, 13, 200]; // threshold = 3 (degree 2)
    // Generate 5 points
    const allXs = [1, 2, 3, 4, 5];
    const allYs = allXs.map((x) => horner(x, coefficients));

    // Recover from different subsets of 3 points
    const subsets = [
      [0, 1, 2],
      [0, 2, 4],
      [1, 3, 4],
      [2, 3, 4],
    ];

    for (const indices of subsets) {
      const xs = indices.map((i) => allXs[i]);
      const ys = indices.map((i) => allYs[i]);
      const recovered = lagrange(0, [xs, ys]);
      expect(recovered).toBe(a0);
    }
  });

  it('x=0 recovery matches original secret byte for various secrets', () => {
    const secrets = [0, 1, 127, 128, 255];
    for (const secret of secrets) {
      const coefficients = [secret, 33, 120];
      const xs = [1, 2, 3];
      const ys = xs.map((x) => horner(x, coefficients));
      const recovered = lagrange(0, [xs, ys]);
      expect(recovered).toBe(secret);
    }
  });
});
